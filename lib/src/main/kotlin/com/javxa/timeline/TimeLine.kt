/*
 * This source file was generated by the Gradle 'init' task
 */
package com.javxa.timeline

import org.junit.jupiter.api.DynamicTest
import java.util.*
import java.util.logging.Logger
import java.util.stream.Stream
import kotlin.streams.asStream

interface TimeLineTracker {
    val timelineIndex: Int
    val branch: Boolean

    fun branch(name: String? = null, notifySkipped: Boolean = true): Boolean
    fun <T> branch(paths: Iterable<T>): T
    fun <T> branch(name: String, paths: Iterable<T>): T
}

private data class BranchInfo(
    val name: String?,
    val path: Any?,
) {
    override fun toString(): String {

        val branchName = name ?: "branch"
        return "$branchName: $path"
    }
}

class TimeLineTrackerImpl(
    private val block: TimeLineTracker.() -> Unit
) : TimeLineTracker, Iterator<DynamicTest> {

    private val log: Logger = Logger.getLogger(TimeLineTracker::class.simpleName)

    override val branch: Boolean
        get() = branch(notifySkipped = true)

    override fun branch(name: String?, notifySkipped: Boolean): Boolean {
        val next = getNextBranch()
        if (next or notifySkipped) {
            currentPathNames.add(BranchInfo(name, next))
        }
        return next
    }

    override fun <T> branch(paths: Iterable<T>): T {
        return branch("branch", paths)
    }

    override fun <T> branch(name: String, paths: Iterable<T>): T {
        val it = paths.iterator()

        if (!it.hasNext())
            throw IllegalStateException("Iterable did not contain any items")

        while (true) {
            val next = it.next()

            if (!it.hasNext()) {
                currentPathNames.add(BranchInfo(name, next))
                return next
            }

            if (getNextBranch()) {
                currentPathNames.add(BranchInfo(name, next))
                return next
            }
        }
    }

    override var timelineIndex = 0
        private set

    // For each traveler, the path is prepared as the one that should be followed
    // When a traveler has reached the end, it is prepared for the next one
    private val paths: MutableList<Boolean> = LinkedList()
    private val currentPathNames: MutableList<BranchInfo> = LinkedList()
    private var travelerIndex = 0

    private fun printCurrentPath() {
        log.info(StringBuilder("\n").apply {
            append("======[ Timeline ]=====\n")
            append("Timeline Index: $timelineIndex\n")
            currentPathNames.forEach {
                append(it).append("\n")
            }

            append("=======================\n")
        }.toString())
    }

    private fun prepareForNext() {
        // paths contain the previous travelled path

        // if the last branch is true, it should switch to false
        // if the last branch is false, we should remove all last false, then switch the last true to false

        printCurrentPath()
        currentPathNames.clear()

        if (paths.isEmpty()) return

        val last = paths.removeLast()

        if (last) {
            paths.add(false)
            return
        }

        while (paths.isNotEmpty() && !paths.last()) {
            paths.removeLast()
        }

        if (paths.isEmpty()) return

        paths.removeLast()
        paths.add(false)
    }

    private fun runNext() {
        travelerIndex = 0
        try {
            block()
        } finally {
            abortTraveler()
            prepareForNext()
            timelineIndex++
        }
    }

    private fun abortTraveler() {
        val size = paths.size
        val branchesTraveled = travelerIndex
        repeat(size - branchesTraveled) {
            paths.removeLast()
        }
    }

    private fun getNextBranch(): Boolean {

        val size = paths.size

        if (travelerIndex == size) {
            paths.add(true)
            travelerIndex++
            return true
        }

        if (travelerIndex > size) {
            throw IllegalStateException("Traveled beyond the event horizon")
        }

        val path = paths[travelerIndex]
        travelerIndex++
        return path
    }

    override fun hasNext(): Boolean {
        val hasNext = timelineIndex == 0 || paths.size > 0
        return hasNext
    }

    override fun next(): DynamicTest {
        return DynamicTest.dynamicTest("timeline $timelineIndex") {
            runNext()
        }
    }

}


fun timeline(block: TimeLineTracker.() -> Unit): Stream<DynamicTest> {
    return TimeLineTrackerImpl(block).asSequence().asStream()
}